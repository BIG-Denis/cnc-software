= Программное описание модуля GUI
:toc:
:toclevels: 3
:sectnums:

== Общие сведения

=== Назначение

Графический пользовательский интерфейс (GUI) предназначен для управления CNC-оборудованием через последовательный порт (COM-порт).
Приложение обеспечивает взаимодействие пользователя с системой управления станком через удобный интерфейс, реализованный с использованием *PyQt5*.

Основные возможности:

* Визуальное проектирование траекторий движения инструмента
* Генерация G-code команд на основе графических операций
* Отправка команд на CNC станок через последовательный порт
* Управление различными режимами рисования (горизонтальное, вертикальное, наклонное, дуги, штриховка)
* Работа с файлами G-code

== Архитектура приложения

=== Технологический стек

* Язык программирования: Python 3
* GUI-фреймворк: PyQt5
* Обработка изображений: PIL (Pillow)
* Работа с последовательными портами: pyserial (через модуль response.py)

=== Зависимости

* *PyQt5* - основной фреймворк для создания графического интерфейса
* *PIL (Pillow)* - библиотека для обработки изображений
* *pyserial* - библиотека для работы с последовательными портами
== Структура файлов

=== Описание файлов

*`main.py`*  
Основной исполняемый файл приложения, cодержит:

* класс `MainWindow` - главное окно приложения;
* класс `GraphicsViewClickFilter` - фильтр событий для обработки кликов;
* вспомогательные функции для генерации G-code и обработки изображений;
* логику инициализации и запуска приложения;
* обработку кодировок для разных платформ.

*`response.py`*  
Модуль для работы с протоколом PRD-3, содержит:

* функции формирования пакетов по протоколу PRD-3;
* вычисление контрольных сумм CRC8;
* отправку G-code команд с разбиением на чанки;
* прием и обработку ответных пакетов;
* обработку кодов подтверждения (ACK).

*`mainwindow.ui`*  
XML-файл описания интерфейса, созданный в *Qt Designer*. Определяет:

* структуру главного окна;
* расположение и свойства виджетов;
* геометрию элементов интерфейса.

== Функциональные возможности

=== Основные функции

==== Обнаружение COM-портов

*Метод:* `GetCOMPorts()`

*Описание:*  
Автоматическое сканирование и обнаружение доступных последовательных портов в системе.

*Реализация:*  
Используется `QSerialPortInfo.availablePorts()` для получения списка портов.

*Результат работы:*

* заполнение выпадающего списка `portsComboBox` найденными портами;
* вывод информации о найденных портах в консоль.

==== Визуальное проектирование траекторий

*Метод:* `draw_img(pre=None)`

*Описание:*  
Отрисовка графического представления траекторий движения инструмента.

*Функциональность:*

* создание изображения размером 330x228 пикселей;
* отрисовка всех выполненных команд;
* предварительный просмотр траекторий (зеленый/оранжевый цвет);
* отображение текущей позиции инструмента (красная точка);
* сохранение изображения в файл `.field_img.png`;
* отображение изображения в графической сцене.

==== Обработка кликов по графическому полю

*Метод:* `on_paint_view_clicked(x, y)`

*Описание:*  
Обработка кликов пользователя по графическому полю для создания траекторий.

*Алгоритм работы:*

1. Обработка и привязка координат (snapping к якорным точкам)
2. Предварительный просмотр траектории
3. Запрос подтверждения у пользователя
4. Генерация и отправка G-code команд
5. Обновление состояния и перерисовка

==== Генерация G-code команд

*Функции:*

* `get_gcode(mode, paint, x, y, ccw, radius)` - генерация G-code команды;
* `get_gcodes_htc(...)` - генерация последовательности команд для штриховки.

*Поддерживаемые команды:*

* `G00` - быстрое перемещение;
* `G01` - линейная интерполяция;
* `G02` - дуга по часовой стрелке;
* `G03` - дуга против часовой стрелки.

==== Режимы рисования

Приложение поддерживает следующие режимы:

* *Горизонтальное перемещение (hrz)* - движение только по оси X;
* *Вертикальное перемещение (vrt)* - движение только по оси Y;
* *Произвольное перемещение (slp)* - движение по прямой линии;
* *Дуга (arc)* - движение по дуге окружности;
* *Штриховка (htc)* - заполнение области параллельными линиями.

==== Управление якорными точками

*Функциональность:*

* добавление якорных точек для привязки;
* автоматическая привязка к ближайшей якорной точке (snapping);
* использование якорных точек для точного позиционирования.

==== Отправка команд

*Методы:*

* `clicked_btn_send_gcode()` - отправка G-code команды, введенной вручную;
* `clicked_btn_send_file()` - отправка G-code команд из файла;
* `clicked_btn_send_hex()` - отправка HEX-пакета.

*Интеграция:*
Используются функции из модуля `response.py`:

* `SendGcode(port, gcodeLines, baudrate)` - отправка G-code команд;
* `SendHex(port, hexString, baudrate)` - отправка HEX-пакетов.

=== Элементы интерфейса

==== Вкладка «Настройка» (tab_2)

*Виджет консоли:* `QPlainTextEdit` (`consoleEdit`)

*Назначение:*  
Отображение системных сообщений и логов.

*Свойства:*
* только для чтения;
* размер: 711x421 пикселей;
* поддержка выделения текста.

*Элементы управления:*
* *Поле ввода Baud Rate* (`baudRateLineEdit`)
** позиция: (140, 40)
** размер: 113x22 пикселей
** значение по умолчанию: 57600
** назначение: ввод скорости передачи данных COM-порта

* *Выпадающий список COM-портов* (`portsComboBox`)
** позиция: (270, 40)
** размер: 121x22 пикселей
** назначение: выбор последовательного порта

* *Кнопка «Обновить»* (`btn_refresh`)
** назначение: обновление списка доступных COM-портов

==== Вкладка «Рисование» (paint)

*Графическое поле:* `QGraphicsView` (`paint_view`)

*Назначение:*  
Интерактивное поле для проектирования траекторий движения инструмента.

*Функциональность:*

* обработка кликов мыши для создания траекторий;
* визуализация выполненных команд;
* отображение текущей позиции инструмента;
* предварительный просмотр траекторий.

*Элементы управления режимами:*

* *Кнопка «Горизонтальное»* (`btn_paint_horizontal`)
** режим: горизонтальное перемещение (hrz)

* *Кнопка «Вертикальное»* (`btn_paint_vertical`)
** режим: вертикальное перемещение (vrt)

* *Кнопка «Наклонное»* (`btn_paint_sloped`)
** режим: произвольное перемещение (slp)

* *Кнопка «Дуга»* (`btn_paint_arc`)
** режим: движение по дуге (arc)

* *Кнопка «Штриховка»* (`btn_paint_hatch`)
** режим: заполнение области штриховкой (htc)

*Параметры рисования:*
* *Радио-кнопки режима* (`btn_radio_paint`, `btn_radio_move`)
** режим рисования или перемещения

* *Радио-кнопка направления дуги* (`btn_radio_paint_ccw`)
** направление дуги (по/против часовой стрелки)

* *Радио-кнопка привязки* (`btn_radio_snapping`)
** включение/выключение привязки к якорным точкам

* *Спинбокс радиуса* (`spinbox_paint_radius`)
** радиус дуги

* *Спинбокс угла штриховки* (`spinbox_paint_hatch_angle`)
** угол наклона линий штриховки

* *Спинбокс расстояния штриховки* (`spinbox_paint_hatch_distance`)
** расстояние между линиями штриховки

*Утилиты:*
* *Кнопка «Калибровка»* (`btn_paint_calibrate`)
** сброс позиции в (0, 0)

* *Кнопка «Очистить изображение»* (`btn_paint_clear_img`)
** очистка всех команд

* *Кнопка «Добавить якорную точку»* (`btn_paint_add_anchor_point`)
** добавление якорной точки в текущей позиции

* *Кнопка «Сдампить G-коды»* (`btn_dump_codes`)
** сохранение всех команд в файл

==== Вкладка «Профессиональная» (pro)

*Элементы управления:*
* *Поле ввода G-code* (`lineEdit_pro_gcode`)
** ввод G-code команды вручную

* *Кнопка «Отправить G-code»* (`btn_pro_gcode_send`)
** отправка введенной команды

* *Поле ввода HEX* (`lineEdit_pro_hex`)
** ввод HEX-пакета вручную

* *Кнопка «Отправить HEX»* (`btn_pro_hex_send`)
** отправка HEX-пакета

* *Кнопка «Выбрать файл»* (`btn_select_file`)
** выбор файла с G-code командами

* *Метка имени файла* (`label_filename`)
** отображение выбранного файла

* *Кнопка «Отправить файл»* (`btn_send_file`)
** отправка команд из выбранного файла

== Технические детали

=== Класс MainWindow

`MainWindow(QMainWindow)`

*Наследование:* `QMainWindow` (PyQt5)

==== Инициализация

*Метод:* `__init__(self)`

*Выполняемые действия:*

* загрузка интерфейса из `mainwindow.ui`
* установка активной вкладки «Настройка» (индекс 0)
* инициализация графической сцены для отображения траекторий
* установка фильтра событий для обработки кликов по графическому полю
* подключение сигналов кнопок к обработчикам
* инициализация переменных состояния
* автоматическое обнаружение COM-портов

*Переменные состояния:*

* `mode` - текущий режим рисования ('hrz', 'vrt', 'slp', 'htc', 'arc')
* `drawing` - флаг режима рисования (True) или перемещения (False)
* `current_x`, `current_y` - текущие координаты инструмента
* `draw_commands` - список выполненных команд рисования
* `g_codes` - список сгенерированных G-code команд
* `anchors` - множество якорных точек для привязки

==== Методы управления COM-портами

*Метод:* `GetCOMPorts(self)`

* создание экземпляра `QSerialPortInfo`
* получение списка доступных портов
* заполнение выпадающего списка
* вывод информации в консоль

*Метод:* `Append(self, text)`

* получение курсора текстового поля
* перемещение курсора в конец
* вставка текста
* прокрутка консоли вниз

==== Методы визуализации

*Метод:* `draw_img(self, pre=None)`

*Описание:*  
Отрисовывает графическое представление траекторий движения инструмента.

*Алгоритм:*

1. Создает изображение размером 330x228 пикселей
2. Отрисовывает все выполненные команды (черный цвет)
3. Отображает предварительный просмотр (зеленый/оранжевый цвет)
4. Отмечает текущую позицию инструмента (красная точка)
5. Сохраняет изображение в файл `.field_img.png`
6. Отображает изображение в графической сцене

==== Обработчики событий

*Метод:* `on_paint_view_clicked(self, x, y)`

*Описание:*  
Обрабатывает клики пользователя по графическому полю.

*Алгоритм:*

1. Обработка и привязка координат (snapping)
2. Предварительный просмотр траектории
3. Запрос подтверждения у пользователя
4. Генерация и отправка G-code команд
5. Обновление состояния и перерисовка

*Методы режимов рисования:*

* `clicked_btn_mode_hrz()` - горизонтальное перемещение
* `clicked_btn_mode_vrt()` - вертикальное перемещение
* `clicked_btn_mode_slp()` - произвольное перемещение
* `clicked_btn_mode_htc()` - штриховка
* `clicked_btn_mode_arc()` - движение по дуге

*Методы управления:*

* `clicked_btn_dump_codes()` - сохранение G-code команд в файл
* `clicked_btn_calibrate()` - калибровка станка (сброс в 0,0)
* `clicked_btn_clear_img()` - очистка всех команд
* `clicked_btn_paint_add_anchor_point()` - добавление якорной точки
* `clicked_btn_select_file()` - выбор файла с G-code
* `clicked_btn_send_file()` - отправка команд из файла
* `clicked_btn_send_gcode()` - отправка G-code команды
* `clicked_btn_send_hex()` - отправка HEX-пакета

=== Класс GraphicsViewClickFilter

`GraphicsViewClickFilter(QObject)`

*Наследование:* `QObject` (PyQt5)

*Назначение:*  
Фильтр событий для обработки кликов по графическому виду.

*Методы:*

* `__init__(self, callback)` - инициализация с callback-функцией
* `eventFilter(self, obj, event)` - перехват событий клика мыши

=== Вспомогательные функции

*Функция:* `nearest_anchor(x, y, anchors)`

*Описание:*  
Находит ближайшую якорную точку к заданным координатам.

*Функция:* `get_gcode(mode, paint, x, y, ccw, radius)`

*Описание:*  
Генерирует G-code команду на основе параметров.

*Функция:* `get_gcodes_htc(...)`

*Описание:*  
Генерирует последовательность G-code команд для штриховки области.

*Функция:* `get_hatch_lines(img, x, y, angle, distance)`

*Описание:*  
Вычисляет линии штриховки для заполнения области.

*Функция:* `draw_gcode_arc(...)`

*Описание:*  
Отрисовывает дугу на изображении.

*Функция:* `confirm(parent, text)`

*Описание:*  
Отображает диалог подтверждения действия.

*Функция:* `alert(parent, text)`

*Описание:*  
Отображает информационное сообщение.

=== Модуль response.py

Модуль `response.py` реализует низкоуровневую работу с протоколом PRD-3 для обмена данными между GUI (master) и CNC станком (worker-ноды).

==== Протокол PRD-3

*Формат исходящего пакета (от master):*
----
[SYNC1] [SYNC2] [LEN] [SQN] [ADDR] [ACK] [DATA...] [CRC]
----

*Формат входящего пакета (ответ от worker):*
----
[SYNC1] [SYNC2] [LEN] [SQN] [ADDR] [ACK] [DATA...] [CRC]
----

*Константы протокола:*

* `SYNC1 = 0xAC` - первое синхрослово
* `SYNC2 = 0x53` - второе синхрослово
* `ADDR = 0x01` - адрес устройства по умолчанию
* `POLY = 0x31` - полином CRC8 (x^8 + x^5 + x^4 + 1)
* Максимальный размер данных: 250 байт

*Коды подтверждения (ACK):*

* `ACK_OK = 0x01` - команда принята и декодирована
* `ACK_BAD_ADDR = 0x02` - неверный адрес устройства
* `ACK_BAD_CRC = 0x03` - ошибка в контрольной сумме
* `ACK_BAD_PARAM = 0x04` - ошибка в параметрах команды

==== Основные функции

*Функция:* `Crc8(data: bytes) -> int`

*Описание:*  
Вычисляет контрольную сумму CRC8 для массива байтов.

*Параметры:*

* `data` - массив байтов для вычисления CRC

*Возвращает:* Значение CRC8 (0-255)

*Алгоритм:*

* Использует полином 0x31 (x^8 + x^5 + x^4 + 1)
* Реализует стандартный алгоритм CRC8

*Функция:* `ChunkBytes(data: bytes, chunkSize: int=250) -> Generator[bytes]`

*Описание:*  
Разбивает массив байтов на чанки заданного размера.

*Параметры:*

* `data` - массив байтов для разбиения
* `chunkSize` - размер чанка (по умолчанию 250 байт)

*Возвращает:* Генератор, возвращающий чанки данных

*Назначение:*  
Разбиение больших объемов данных (G-code файлов) на пакеты, соответствующие ограничениям протокола.

*Функция:* `GcodeListToStr(gcodeLines: list[str]) -> bytes`

*Описание:*  
Преобразует список строк G-code в байтовый поток.

*Параметры:*

* `gcodeLines` - список строк с G-code командами

*Возвращает:* Байтовый массив с G-code командами

*Особенности:*

* Удаляет символы возврата каретки и переноса строки из каждой строки
* Добавляет символ переноса строки (`\n`) в конец каждой команды
* Кодирует результат в ASCII

*Функция:* `MakeResponse(sqn: int, data: bytes, addr: int=ADDR, ack: int=ACK_OK) -> bytes`

*Описание:*  
Формирует ответный пакет по протоколу PRD-3.

*Параметры:*

* `sqn` - последовательный номер пакета (0-255)
* `data` - данные пакета (максимум 250 байт)
* `addr` - адрес устройства (по умолчанию 0x01)
* `ack` - код подтверждения (по умолчанию ACK_OK)

*Возвращает:* Сформированный пакет в виде байтового массива

*Выбрасывает:* `ValueError` если длина данных превышает 250 байт

*Алгоритм:*
. Проверяет длину данных (не более 250 байт)
. Формирует тело пакета: `[SQN, ADDR, ACK] + DATA`
. Вычисляет длину пакета: `LEN = len(body)`
. Формирует пакет без CRC: `[LEN] + body`
. Вычисляет CRC для пакета без CRC
. Формирует итоговый пакет: `[SYNC1, SYNC2] + [LEN] + body + [CRC]`

*Функция:* `ReadAckPacket(ser: serial.Serial, timeout: float = 0.05) -> Optional[int]`

*Описание:*  
Читает ответный пакет из последовательного порта и извлекает код ACK.

*Параметры:*

* `ser` - открытый объект `serial.Serial`
* `timeout` - таймаут ожидания пакета в секундах (по умолчанию 0.05)

*Возвращает:*

* Код ACK (0x01-0x04) при успешном чтении
* `None` при таймауте или ошибке чтения
* `ACK_BAD_CRC` (0x03) при ошибке CRC

*Алгоритм:*
. Ищет синхрослова в потоке данных (SYNC1, затем SYNC2)
. Читает поле LEN (длина пакета)
. Читает тело пакета (SQN, ADDR, ACK, DATA) и CRC
. Проверяет корректность CRC
. Возвращает значение поля ACK

*Особенности:*

* Использует таймаут для предотвращения зависания
* Проверяет целостность данных (длина, CRC)
* Возвращает `ACK_BAD_CRC` при ошибке CRC вместо `None`

*Функция:* `SendHex(port: str, hexString: str, baudrate: int) -> bool`

*Описание:*  
Отправляет готовый HEX-пакет через последовательный порт.

*Параметры:*

* `port` - имя COM-порта (например, "COM1" или "/dev/ttyUSB0")
* `hexString` - HEX-строка с пакетом (с пробелами или без)
* `baudrate` - скорость передачи данных

*Возвращает:* `True` при успешной отправке, `False` при ошибке

*Алгоритм:*
. Удаляет пробелы и переводы строк из HEX-строки
. Преобразует HEX-строку в байтовый массив
. Открывает последовательный порт (8N1, timeout=0.01)
. Отправляет данные
. Ожидает 0.01 секунды для завершения передачи
. Закрывает порт

*Обработка ошибок:*

* Перехватывает все исключения
* Закрывает порт при ошибке (если был открыт)
* Возвращает `False` при любой ошибке

*Функция:* `SendGcode(port: str, gcodeLines: list[str], baudrate: int, chunkSize: int=250, retries: int=3) -> bool`

*Описание:*  
Отправляет G-code команды через последовательный порт с использованием протокола PRD-3.

*Параметры:*

* `port` - имя COM-порта
* `gcodeLines` - список строк с G-code командами
* `baudrate` - скорость передачи данных
* `chunkSize` - размер чанка данных (по умолчанию 250 байт)
* `retries` - количество попыток повторной отправки при ошибке (по умолчанию 3)

*Возвращает:* `True` при успешной отправке всех команд, `False` при ошибке

*Алгоритм:*
. Открывает последовательный порт
. Преобразует список G-code команд в байтовый поток
. Разбивает данные на чанки по 250 байт
. Для каждого чанка:
.. Формирует пакет с текущим SQN
.. Отправляет пакет
.. Читает ответный пакет
.. Обрабатывает код ACK:
... `ACK_OK` - успех, переходим к следующему чанку
... `ACK_BAD_CRC` или `None` - повторная попытка (до `retries` раз)
... `ACK_BAD_ADDR` или `ACK_BAD_PARAM` - критическая ошибка, прекращение отправки
.. Инкрементирует SQN для следующего пакета
.. Делает паузу 0.005 секунды между пакетами
. Закрывает порт

*Особенности:*

* Автоматическое разбиение больших файлов на пакеты
* Повторная отправка при ошибках CRC
* Немедленное прекращение при критических ошибках (неверный адрес, параметры)
* Управление последовательными номерами пакетов (SQN)

==== Обработка ошибок

*Типы ошибок и их обработка:*

* *ACK_OK (0x01)* - Команда принята успешно
** Действие: Переход к следующему пакету

* *ACK_BAD_CRC (0x03)* - Ошибка контрольной суммы
** Действие: Повторная отправка пакета (до `retries` раз)
** Пауза: 0.02 секунды перед повторной попыткой

* *ACK_BAD_ADDR (0x02)* - Неверный адрес устройства
** Действие: Немедленное прекращение отправки
** Возврат: `False`

* *ACK_BAD_PARAM (0x04)* - Ошибка в параметрах команды
** Действие: Немедленное прекращение отправки
** Возврат: `False`

* *Таймаут или отсутствие ответа* (`None`)
** Действие: Повторная отправка пакета (до `retries` раз)
** Пауза: 0.02 секунды перед повторной попыткой

==== Интеграция с main.py

Модуль `response.py` используется в `main.py` через следующие вызовы:

* В методе `on_paint_view_clicked()`:
** `SendGcode()` - для отправки G-code команд при клике на графическое поле

* В методе `clicked_btn_send_gcode()`:
** `SendGcode()` - для отправки G-code команды, введенной вручную

* В методе `clicked_btn_send_file()`:
** `SendGcode()` - для отправки G-code команд из файла

* В методе `clicked_btn_send_hex()`:
** `SendHex()` - для отправки HEX-пакета, введенного вручную

* В методе `clicked_btn_calibrate()`:
** `SendGcode()` - для отправки команды калибровки (G00 X0 Y0)

=== Обработка кодировок

Приложение автоматически определяет кодировку в зависимости от платформы:

* Windows - `cp1251`
* Другие ОС - `utf-8`

=== Точка входа

[source,python]
----
if __name__ == "__main__":
----

*Последовательность запуска:*

. определение кодировки по платформе
. создание экземпляра `QApplication`
. создание и отображение главного окна
. запуск цикла обработки событий

== Параметры интерфейса

=== Главное окно

* размер: 800x600 пикселей
* заголовок: `MainWindow`

*Компоненты:*

* центральный виджет с вкладками
* меню (`menubar`)
* строка состояния (`statusbar`)

=== Вкладки

* вкладка 0 - «Консоль»
* вкладка 1 - «Функционал»


=== Требования

* Python 3.6 или выше
* PyQt5 5.12 или выше
* Pillow (PIL) 8.0 или выше
* pyserial 3.0 или выше

== Установка и запуск

=== Установка зависимостей

[source,bash]
----
pip install PyQt5 Pillow pyserial
----

=== Запуск приложения

[source,bash]
----
python main.py
----

=== Требования к файлам

* Файл `mainwindow.ui` должен находиться в той же директории, что и `main.py`
* Файл `response.py` должен находиться в той же директории, что и `main.py`

=== Структура проекта

[source]
----
gui/
├── main.py              # Основной модуль приложения
├── response.py           # Модуль работы с протоколом PRD-3
├── mainwindow.ui         # Описание интерфейса
└── README_main.md        # Техническое описание main.py
└── README_response.md    # Техническое описание response.py
----

== Формат файлов

=== Входные файлы

* *Файлы G-code* - текстовые файлы с G-code командами (одна команда на строку)
* *mainwindow.ui* - XML-файл описания интерфейса Qt Designer

=== Выходные файлы

* *g_codes_dump.cnc* - дамп всех сгенерированных G-code команд
* *.field_img.png* - временный файл с изображением траекторий

== Особенности реализации

=== Управление состоянием

* Все команды сохраняются в списках для возможности отмены/повтора
* Текущая позиция отслеживается для корректной генерации относительных команд
* Якорные точки используются для точной привязки

=== Визуализация

* Предварительный просмотр отображается другим цветом (зеленый/оранжевый)
* Текущая позиция отображается красной точкой
* Изображение перерисовывается при каждом изменении

=== Обработка ошибок

* Проверка успешности отправки команд
* Отображение сообщений об ошибках пользователю
* Восстановление состояния при ошибках

=== Протокол обмена данными

Приложение использует протокол PRD-3 для обмена данными с CNC станком:

*Формирование пакетов:*

* Пакеты формируются с синхрословами (SYNC1=0xAC, SYNC2=0x53)
* Добавление контрольных сумм CRC8 (полином 0x31)
* Управление последовательными номерами пакетов (SQN, 0-255)

*Разбиение данных:*

* Большие файлы автоматически разбиваются на чанки по 250 байт
* Каждый чанк отправляется отдельным пакетом с уникальным SQN
* Последовательная отправка чанков с паузами между пакетами

*Обработка ошибок:*

* Повторная отправка при ошибках CRC (до 3 попыток)
* Немедленное прекращение при критических ошибках (неверный адрес, параметры)
* Обработка таймаутов при отсутствии ответа

*Таймауты и задержки:*

* Таймаут чтения ответного пакета: 0.05 секунды (50 мс)
* Пауза между повторными попытками: 0.02 секунды
* Пауза между пакетами: 0.005 секунды
* Таймаут последовательного порта: 0.01 секунды

*Коды подтверждения (ACK):*

* `ACK_OK` (0x01) - команда принята успешно
* `ACK_BAD_ADDR` (0x02) - неверный адрес устройства
* `ACK_BAD_CRC` (0x03) - ошибка контрольной суммы
* `ACK_BAD_PARAM` (0x04) - ошибка в параметрах команды
